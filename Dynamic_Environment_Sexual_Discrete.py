#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Last update, 16/01/2018
Discrete Replicator Dynamic in Sexual model
Under the Dynamic Environment
@author: Shota Shibasaki
"""

import numpy as np
from scipy.linalg import cholesky
import matplotlib.pyplot as plt
import csv
from sklearn import svm, datasets, cross_validation
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import cross_val_score

#parameter
a1=1
b1=1.2
e0=0.000001
e1=0.0001
e2=0.0001
h=0.5
a2=0.6
b2=1.2
theta_both=0.9#prob of marcocyst formation between mating types
T=500
C=5#parameter for Linear SVM
Trial =20 # number of total trials

"""
Note
FB = fruiting body
MC = macrocsyt
"""

def Matrix(a2,b2,theta):
   """
   Defining patoff matrixes
   A1: payoff matrix for fruiting body formation
   A2: payoff matrix for macrocyst formation
   A: patoff matrix generated by the mixture of A1 and A2.
      see Eq [2] in the main text for more detail.
   Parameters
   a2: benefit of cmutual ooperation in macrocyst formation
   b2: benefit of exploitation for defectors in macrocyst formation
   theta: prob. of macrocyst fromation
      
   """
   A1=np.array([[a1,h*a1,0],\
                 [e0,e0,e0],\
                 [b1,h*e1,e1]])
    
   A2=np.array([[a2,0,a2],\
                 [b2,e2,b2],\
                 [a2,0,a2]])
   A=(1-theta)*A1+(theta)*A2
   return A

def func(x, t, a2,b2,theta,w):
    """
    Continuous replicator dynamics
    x: array of the frequency of the three strategy
    t: time
    a2, b2, theta: defined in function Matrix
    w: fruiting body formation is prevented or not
    w=0 -> unable to form fruiting bodies, only MC formation occurs
    w=1 -> able to form fruiting bodies
    """
    #x is array and A is matrix
    #if w=0 there is no effect of fruiting body formation
    Aa=w*Matrix(a2,b2,0)#asexual
    As=Matrix(a2,b2,theta)#sexual
    A1=np.c_[Aa,As]#extend colum
    A2=np.c_[As,Aa]
    A=np.r_[A1,A2]#complete payoff
    phi=np.dot(x,A)
    phi=np.dot(phi,x.T)#mean fitness in the population
    #calculate replicator dynamics
    f0=np.dot(A[0,:],x.T)/phi#C1
    f1=np.dot(A[1,:],x.T)/phi#DM1
    f2=np.dot(A[2,:],x.T)/phi#DF1 
    f3=np.dot(A[3,:],x.T)/phi#C2
    f4=np.dot(A[4,:],x.T)/phi#DM2
    f5=np.dot(A[5,:],x.T)/phi#DF2 
    f=np.array([x[0]*f0,x[1]*f1,x[2]*f2,x[3]*f3,x[4]*f4,x[5]*f5])
    
    return(f)
def classify(cls):
    """
    Check the class of the environmental condition and
    return the theta and w
    cls: class of give environmental condition
    
    """
    if cls==0:
        #neither
        theta=-1
    elif cls==1:
        #FB only
        theta=0
        w=1
    elif cls==2:
        #only MC
        theta=1
        w=0
    else:
        #both
        theta=theta_both
        w=1
    return [theta,w]   

def Save_Csv(file_name, array):
    #save csv file given file name and array
    with open(file_name, 'w') as f:
             writer=csv.writer(f)
             writer.writerows(array)
    
def main():
    #classificasion by LinearSVC
    with open('exp_result.csv','r') as f:
        #note that 'exp_result.csv' is the same as 'SI_dataset.csv'.
        data=csv.reader(f)
        header=next(data)
        counter=0
        c0x=[]
        c0y=[]
        c1y=[]
        c1x=[]
        c2y=[]
        c2x=[]
        c3x=[]
        c3y=[]
        X=np.empty((0,2),float) #input data
        y=np.array([])
        C0X=np.array([])
        C0Y=np.array([])
        C1X=np.array([])
        C1Y=np.array([])
        C2X=np.array([])
        C2Y=np.array([])
        C3X=np.array([])
        C3Y=np.array([])
        for row in data:
            
            counter+=1
            if row[2]=="0": #neither FBs nor MCs are formed
                c0x.append(row[0])
                c0y.append(row[1])
                X=np.append(X, np.array([[float(row[0])*0.001,float(row[1])]]), axis=0)
                y=np.append(y, np.array([[int(row[2])]]))
                C0X=np.append(C0X, np.array([[float(row[0])*0.001]]))
                C0Y=np.append(C0Y, np.array([[float(row[1])]]))
                
            
            elif row[2]=="1": #only FBs are formed 
                c1x.append(row[0])
                c1y.append(row[1])
                C1X=np.append(C1X, np.array([[float(row[0])*0.001]]))
                C1Y=np.append(C1Y, np.array([[float(row[1])]]))
                X=np.append(X, np.array([[float(row[0])*0.001,float(row[1])]]), axis=0)
                y=np.append(y, np.array([[int(row[2])]]))
                    
            elif row[2]=="2": # only MCs areformed 
                c2x.append(row[0])
                c2y.append(row[1])
                X=np.append(X, np.array([[float(row[0])*0.001,float(row[1])]]), axis=0)
                y=np.append(y, np.array([[int(row[2])]]))
                C2X=np.append(C2X, np.array([[float(row[0])*0.001]]))
                C2Y=np.append(C2Y, np.array([[float(row[1])]]))
                    
            else:
                #both FBs and MCs are formed  
                c3x.append(row[0])
                c3y.append(row[1])
                X=np.append(X, np.array([[float(row[0])*0.001,float(row[1])]]), axis=0)
                y=np.append(y, np.array([[int(row[2])]]))
                C3X=np.append(C3X, np.array([[float(row[0])*0.001]]))
                C3Y=np.append(C3Y, np.array([[float(row[1])]]))
            
    sc = StandardScaler()
    sc.fit(X)
    X=sc.transform(X)
    clf=svm.LinearSVC(C=C, dual=False, multi_class='ovr')
    clf.fit(X, y)
    title_env="Environmental_Dynamics"
    title_dyn="Population_Dynamics_DynamicsEnvironment"
    
    """
    Start the simulation under the dynamic environment
    """
    for tri in range(Trial):
        title_tri=str("_trial%d" %(tri+1))
        #iniital condition
        strainnumber=6
        init=np.ones(strainnumber)
        init=init/sum(init)#all strategies coexist with equal frequency
        t0=0
        p=np.empty((0,strainnumber))
        p=np.append(p, [init], axis=0)
        time =np.zeros(T+1)
        time[0]=t0
        """
        Randonly give the inital environmental condition 
        """
        z_next=np.random.randn(2)#Gaussian with mean 0 and variance 1 for 2 dimensions
        z_sigma=0.05#variance
        z_val=np.array([[z_sigma,0],[0,z_sigma]])#covariance matrix
        Env_init=clf.predict([z_next])
        Env=np.empty((0,1))
        Env=np.append(Env,[Env_init], axis=0)
        #start the simulation in discrete replicator dynamics
        for t in range(T):
            time[t+1]=t0+t+1
            q=p[t]
            z_init=z_next
            #environmental dynamics
            z_next=np.random.multivariate_normal(z_init,z_val)
            env=clf.predict([z_next])
            #Env[t+1]=env
            Env=np.append(Env,[env], axis=0)
            #result of the environemntal dynamics
            if env==0:
                #no game as neither FBs nor MC are formed
                pnext=q
                p=np.append(p, [pnext], axis=0)
            else:
                theta,w=classify(env)
                pnext=func(q,t,a2,b2,theta,w)
                p=np.append(p, [pnext], axis=0)
        #plot the reults of environemntal dynamics
        plt.plot(time,Env,linewidth=3,color="g")
        plt.xlabel("time",fontsize=14)
        plt.ylabel("game types",fontsize=14)
        plt.ylim(0,3.5)
        plt.savefig(title_env+title_tri+".eps")
        plt.show()
        #plot the reults of evolutionary dynamics
        plt.plot(time,p[:,0],linewidth=3, linestyle="-",color="c",label="$C_1$")
        plt.plot(time,p[:,2],linewidth=3, linestyle="-",color="y",label="$D_1^F$")
        plt.plot(time,p[:,1],linewidth=3, linestyle="-",color="m",label="$D_1^M$")
        #plt.plot(time,p[:,3],linewidth=3, linestyle="--",color="c",label="$C_2$")
        #plt.plot(time,p[:,5],linewidth=3, linestyle="--",color="y",label="$D_2^F$")
        #plt.plot(time,p[:,4],linewidth=3, linestyle="--",color="m",label="$D_2^M$")      
        plt.xlabel("time",fontsize=14)
        plt.ylabel("frequency",fontsize=14)
        plt.legend(loc="upper left",fontsize=14)
        plt.ylim(0,0.6)
        plt.savefig(title_dyn+title_tri+".eps")
        plt.show()
        
        #save csv
        Save_Csv(title_env+title_tri+".csv",Env)
        Save_Csv(title_dyn+title_tri+".csv",p)
if __name__ == '__main__':
    main()    
